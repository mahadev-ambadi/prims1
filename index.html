<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MST Games ‚Äî Kruskal & Prim Interactive</title>
<style>
  :root{
    --bg:#a1a7af; --panel:#61e86a; --muted:#9ca3af; --accent:#34d399; --accent2:#60a5fa;
    --danger:#f87171; --card:#0f1720;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:Inter, "Segoe UI", system-ui, Arial;
    background:var(--bg);
    color:#cbd5e1;
    display:flex;
    justify-content:center;
    padding:20px;
    height:100vh;
  }
  .container{display:flex;gap:20px;width:100%;max-width:1400px}
  canvas{
    flex:1;
    background:linear-gradient(135deg,#578bdf,rgb(14, 193, 172));
    border-radius:14px;
    box-shadow:0 12px 40px rgba(122, 194, 45, 0.6);
    cursor:crosshair;
    display:block;
  }
  .sidebar{
    width:360px;
    background:var(--panel);
    border-radius:14px;
    padding:18px;
    box-shadow:0 8px 24px rgba(2,6,23,0.6);
    display:flex;
    flex-direction:column;
    gap:14px;
  }
  h1{margin:0;font-size:20px;color:#60a5fa;text-align:center}
  .card{background:var(--card);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
  .row{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
  .label{color:#9ee7c5;font-weight:600}
  .value{color:#cbd5e1;font-weight:700}
  select,input[type=number]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#09111a;color:#cbd5e1}
  button{padding:12px;border-radius:10px;border:none;font-weight:700;cursor:pointer;background:linear-gradient(135deg,#238636,#2ea043);color:white}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cbd5e1}
  .small{font-size:13px;color:var(--muted)}
  #optimalInfo{font-family:monospace;color:var(--accent);white-space:pre-wrap;margin-top:8px}
  .leaderboard{max-height:150px;overflow:auto;padding:8px;border-radius:8px;background:#071018;border:1px solid rgba(255,255,255,0.02)}
  .lb-item{padding:6px;border-bottom:1px solid rgba(255,255,255,0.02);font-size:13px}
  .lb-item:last-child{border-bottom:none}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .info-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .muted{color:var(--muted)}
  footer{margin-top:6px;text-align:center;color:var(--muted);font-size:13px}
</style>
</head>
<body>
  <div class="container">
    <canvas id="board" width="1000" height="720"></canvas>

    <div class="sidebar">
      <h1>MST Builder ‚Äî Kruskal & Prim</h1>

      <div class="card">
        <div class="row"><div class="label">Algorithm</div>
          <select id="modeSelect">
            <option value="kruskal">Kruskal's MST Builder</option>
            <option value="prim">Prim's MST Explorer</option>
          </select>
        </div>

        <div class="row"><div class="label">Nodes</div>
          <input id="nodeCount" type="number" min="4" max="12" value="8" /></div>

        <div style="margin-top:8px" class="controls">
          <button id="newBtn">üÜï New Graph</button>
          <button id="resetBtn" class="secondary">Reset Progress</button>
        </div>

        <div style="margin-top:10px" class="info-grid">
          <div class="small muted">Timer</div><div id="timer" class="value">00:00</div>
          <div class="small muted">Mistakes</div><div id="mistakes" class="value">0</div>
          <div class="small muted">Edges in MST</div><div id="pickedCount" class="value">0</div>
          <div class="small muted">MST Cost</div><div id="mstCost" class="value">-</div>
          <div class="small muted">Accuracy</div><div id="accuracy" class="value">-</div>
        </div>
      </div>

      <div class="card">
        <div class="label" style="margin-bottom:8px">How to play</div>
        <div class="small">
          ‚Ä¢ In <b>Kruskal</b>, click the smallest-weight edge (that doesn't create a cycle).<br>
          ‚Ä¢ In <b>Prim</b>, start node is random; click the smallest edge connecting the tree to a new vertex.<br>
          ‚Ä¢ Correct picks turn <span style="color:var(--accent)">green</span>, wrong picks flash <span style="color:var(--danger)">red</span>.<br>
          ‚Ä¢ Finish when MST has <code>n-1</code> edges ‚Äî compare cost to optimal.
        </div>
      </div>

      <div class="card">
        <div class="label">Run</div>
        <div class="controls" style="margin-top:8px">
          <button id="solveBtn" class="secondary">Show Optimal MST</button>
          <button id="exportBtn" class="secondary">Export Graph (JSON)</button>
        </div>
        <div id="optimalInfo" style="margin-top:8px">-</div>
      </div>

      <div class="card">
        <div class="label">Leaderboard (best time)</div>
        <div id="leaderboard" class="leaderboard">No scores yet</div>
      </div>

      <footer>Built with ‚ù§Ô∏è ‚Äî pick edges carefully!</footer>
    </div>
  </div>

<script>  
/* ---------- MST Interactive Game (Kruskal + Prim) ---------- */

/* UTILITIES */
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
function segDist(a,b,p){
  // distance from point p to segment ab
  const vx=b.x-a.x, vy=b.y-a.y;
  const wx=p.x-a.x, wy=p.y-a.y;
  const c = (vx*wx + vy*wy);
  const d = (vx*vx + vy*vy);
  let t = d===0?0:Math.max(0, Math.min(1, c/d));
  const proj = { x: a.x + vx*t, y: a.y + vy*t };
  return Math.hypot(p.x-proj.x, p.y-proj.y);
}

/* DOM */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const newBtn = document.getElementById('newBtn');
const resetBtn = document.getElementById('resetBtn');
const solveBtn = document.getElementById('solveBtn');
const exportBtn = document.getElementById('exportBtn');
const modeSelect = document.getElementById('modeSelect');
const nodeCountInput = document.getElementById('nodeCount');
const timerEl = document.getElementById('timer');
const mistakesEl = document.getElementById('mistakes');
const pickedCountEl = document.getElementById('pickedCount');
const mstCostEl = document.getElementById('mstCost');
const optimalInfo = document.getElementById('optimalInfo');
const leaderboardEl = document.getElementById('leaderboard');

let NODE_COUNT = parseInt(nodeCountInput.value,10) || 8;

/* STATE */
let nodes = [];        // {x,y}
let edges = [];        // {u,v,w,accepted:boolean,flash:null}
let mstEdges = [];     // accepted edges (objects refer to edges array)
let mistakes = 0;
let timerStart = null, timerInterval = null;
let algorithmMode = modeSelect.value; // 'kruskal' | 'prim'
let primVisited = new Set();
let primStart = null;
let optimalMST = null;
let leaderboard = JSON.parse(localStorage.getItem('mst_leaderboard')||'[]');

/* HELPERS - Graph generation and solution */
function generateGraph(n){
  nodes = [];
  edges = [];
  mstEdges = [];
  mistakes = 0;
  primVisited = new Set();
  primStart = null;
  optimalMST = null;
  NODE_COUNT = n;

  // place nodes randomly but spread out
  const margin = 50;
  for(let i=0;i<n;i++){
    nodes.push({
      x: margin + Math.random()*(canvas.width - 2*margin),
      y: margin + Math.random()*(canvas.height - 2*margin)
    });
  }

  // create complete graph edges with Euclidean weight
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const w = dist(nodes[i], nodes[j]);
      edges.push({ u:i, v:j, w: w, accepted:false, flash:null });
    }
  }

  // sort edge list for internal optimal MST computations
  computeOptimalMST(); // also sets optimalMST
  resetTimer();
  render();
  updateUI();
}

/* Kruskal to compute optimal MST (helper) */
function computeOptimalMST(){
  const n = nodes.length;
  const sorted = edges.slice().sort((a,b)=>a.w - b.w);
  const parent = Array(n).fill(0).map((_,i)=>i);
  function find(x){ return parent[x]===x?x:(parent[x]=find(parent[x])); }
  let count=0, total=0;
  let picked = [];
  for(const e of sorted){
    const a=find(e.u), b=find(e.v);
    if(a!==b){
      parent[a] = b;
      picked.push(e);
      total += e.w;
      count++;
      if(count===n-1) break;
    }
  }
  optimalMST = { edges: picked, cost: total };
  optimalInfo.textContent = `Optimal MST cost: ${total.toFixed(2)}`;
  return optimalMST;
}

/* Prim's optimal MST (alternative check) */
function computePrimMST(){
  // not necessary since computeOptimalMST uses Kruskal on full graph,
  // but we can verify if needed.
}

/* ---- Union-Find for gameplay Kruskal check ---- */
function canAddEdgeKruskal(e){
  // determine if adding e would form a cycle given current mstEdges
  const n = nodes.length;
  const parent = Array(n).fill(0).map((_,i)=>i);
  function find(x){ return parent[x]===x?x:(parent[x]=find(parent[x])); }
  function unite(a,b){ parent[find(a)] = find(b); }
  // unite from mstEdges
  for(const me of mstEdges){
    unite(me.u, me.v);
  }
  // now check
  return find(e.u) !== find(e.v); // true if safe (does not create cycle)
}

/* ---- Kruskal valid candidate edges ---- */
function kruskalCandidates(){
  // candidate edges are the edges with smallest weight among edges that don't create cycle
  // but Kruskal chooses in global sorted order the smallest that doesn't form cycle.
  // So compute the next minimal weight among remaining edges that don't create cycle.
  const remaining = edges.filter(e => !e.accepted);
  remaining.sort((a,b)=>a.w - b.w);
  // find smallest weight edge that doesn't create cycle
  const candidates = [];
  let minw = Infinity;
  for(const e of remaining){
    if(canAddEdgeKruskal(e)){
      if(minw === Infinity) { minw = e.w; candidates.push(e); }
      else if(Math.abs(e.w - minw) < 1e-9) candidates.push(e);
      else break;
    }
  }
  return candidates; // possibly multiple same-weight edges
}

/* ---- Prim candidate edges ---- */
function primCandidates(){
  // edges connecting primVisited to unvisited, with minimal weight(s)
  const candidates = [];
  let minw = Infinity;
  for(const e of edges){
    if(e.accepted) continue;
    const a = e.u, b = e.v;
    const inA = primVisited.has(a), inB = primVisited.has(b);
    if((inA && !inB) || (!inA && inB)){
      if(e.w < minw - 1e-9){ minw = e.w; candidates.length = 0; candidates.push(e); }
      else if(Math.abs(e.w - minw) < 1e-9) candidates.push(e);
    }
  }
  return candidates;
}

/* ----- Game actions ----- */
function acceptEdge(e){
  e.accepted = true;
  mstEdges.push(e);
  pickedCountEl.textContent = mstEdges.length;
  // update primVisited if in prim mode
  if(algorithmMode === 'prim'){
    // add the newly reached node
    if(primVisited.has(e.u)) primVisited.add(e.v);
    else primVisited.add(e.u);
  }
  render();
  updateUI();
  checkFinish();
}

function wrongPick(e){
  mistakes++;
  mistakesEl.textContent = mistakes;
  e.flash = { color: 'red', expiry: Date.now() + 450 };
  render();
  setTimeout(()=>{ e.flash = null; render(); }, 450);
  updateUI();
}

/* ----- Detect edge under mouse (canvas click) ----- */
function edgeAtPoint(cx, cy){
  const p = {x: cx, y: cy};
  for(const e of edges){
    // draw order: we want easier selection if clicking near edge - check distance
    const a = nodes[e.u], b = nodes[e.v];
    const d = segDist(a,b,p);
    if(d < 7) return e;
  }
  return null;
}

/* ----- Event handlers for gameplay clicks ----- */
canvas.addEventListener('click', (ev) => {
  if(!nodes.length) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX - rect.left) * (canvas.width/rect.width);
  const my = (ev.clientY - rect.top) * (canvas.height/rect.height);
  const e = edgeAtPoint(mx, my);
  if(!e) return;

  // if it's already accepted, ignore
  if(e.accepted) return;

  if(algorithmMode === 'kruskal'){
    const candidates = kruskalCandidates();
    // check if clicked edge is one of candidates (based on object identity by u/v/w)
    const ok = candidates.some(c => (c.u===e.u && c.v===e.v && Math.abs(c.w-e.w)<1e-9));
    // ensure not creating cycle (defensive)
    if(ok && canAddEdgeKruskal(e)){
      acceptEdge(e);
    } else {
      wrongPick(e);
    }
  } else {
    // prim
    const candidates = primCandidates();
    const ok = candidates.some(c => (c.u===e.u && c.v===e.v && Math.abs(c.w-e.w)<1e-9));
    if(ok){
      acceptEdge(e);
    } else {
      wrongPick(e);
    }
  }
});

/* ----- Finish check ----- */
function checkFinish(){
  if(mstEdges.length === nodes.length - 1){
    // compute MST cost
    const total = mstEdges.reduce((s,ex)=>s+ex.w,0);
    mstCostEl.textContent = total.toFixed(2);
    clearInterval(timerInterval);
    // compare with optimal
    const optimalCost = optimalMST ? optimalMST.cost : computeOptimalMST().cost;
    const delta = total - optimalCost;
    const deltaText = delta <= 1e-6 ? 'Matches optimal!' : `+${delta.toFixed(2)} above optimal`;

    // compute accuracy
    const accuracy = mstEdges.length + mistakes > 0 ? (mstEdges.length / (mstEdges.length + mistakes)) * 100 : 100;
    document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';

    optimalInfo.textContent = `Finished! Cost ${total.toFixed(2)} ‚Äî optimal ${optimalCost.toFixed(2)} (${deltaText}) ‚Äî Accuracy: ${accuracy.toFixed(1)}%`;
    
    // add to leaderboard
    const timeSec = Math.round((Date.now() - timerStart)/1000);
    saveLeaderboardEntry({ mode: algorithmMode, time: timeSec, mistakes: mistakes, cost: total });
  }
}

/* ----- Timer ----- */
function resetTimer(){
  clearInterval(timerInterval);
  timerStart = Date.now();
  timerEl.textContent = '00:00';
  timerInterval = setInterval(()=>{
    const elapsed = Date.now() - timerStart;
    const m = Math.floor(elapsed/60000);
    const s = Math.floor((elapsed%60000)/1000);
    timerEl.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }, 500);
}

/* ----- UI Render ----- */
function render(){
  ctx.clearRect(0,0,canvas.width, canvas.height);

  // draw edges (base)
  for(const e of edges){
    const a = nodes[e.u], b = nodes[e.v];
    // line styles
    if(e.accepted){
      ctx.strokeStyle = '#22c55e'; // green
      ctx.lineWidth = 4;
    } else if(e.flash && e.flash.color === 'red'){
      ctx.strokeStyle = '#fb7185';
      ctx.lineWidth = 4;
    } else {
      // candidate highlight
      let cand = false;
      if(algorithmMode === 'kruskal') {
        const cands = kruskalCandidates();
        cand = cands.some(c => c.u===e.u && c.v===e.v && Math.abs(c.w-e.w)<1e-9);
      } else {
        const cands = primCandidates();
        cand = cands.some(c => c.u===e.u && c.v===e.v && Math.abs(c.w-e.w)<1e-9);
      }
      if(cand){
        ctx.strokeStyle = '#161b22'; ctx.lineWidth=3; // gold glow
      } else {
        ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth=1.4;
      }
    }
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();

    // draw weight label near midpoint
    const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(mx-18, my-12, 36, 20);
    ctx.fillStyle = '#c7f9da';
    ctx.font = '12px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(e.w.toFixed(0), mx, my);
  }

  // draw nodes on top
  for(let i=0;i<nodes.length;i++){
    const p = nodes[i];
    ctx.beginPath();
    ctx.fillStyle = '#0b1220';
    ctx.arc(p.x, p.y, 14, 0, Math.PI*2); ctx.fill();
    // outer ring
    ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.stroke();
    // number
    ctx.fillStyle = '#cbd5e1'; ctx.font='12px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(String(i), p.x, p.y);
  }
}

/* ----- UI & state updates ----- */
function updateUI(){
  mistakesEl.textContent = mistakes;
  pickedCountEl.textContent = mstEdges.length;
  if(optimalMST) mstCostEl.textContent = optimalMST.cost.toFixed(2);
  else mstCostEl.textContent = '-';
}

/* ----- Solve (show optimal MST on canvas) ----- */
function showOptimal(){
  if(!optimalMST) computeOptimalMST();
  // mark all edges false then mark optimal edges accepted temporarily (but don't alter game state)
  // We'll render them in green by drawing them specially
  const overlayEdges = optimalMST.edges;
  // temporarily draw overlay
  render();
  // draw overlay green thicker
  ctx.lineWidth=4; ctx.strokeStyle = '#10b981';
  for(const e of overlayEdges){
    const a = nodes[e.u], b = nodes[e.v];
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  optimalInfo.textContent = `Showing optimal MST cost: ${optimalMST.cost.toFixed(2)}`;
}

/* ----- Export graph to JSON ----- */
function exportGraph(){
  const payload = { nodes: nodes.map(n=>({x:n.x,y:n.y})), edges: edges.map(e=>({u:e.u,v:e.v,w:e.w})) };
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='mst_graph.json'; a.click();
  URL.revokeObjectURL(url);
}

/* ----- Leaderboard ----- */
function saveLeaderboardEntry(entry){
  // entry = { mode, time (sec), mistakes, cost }
  leaderboard.push(entry);
  // sort by mode then time small -> mistakes small
  leaderboard.sort((a,b)=> (a.mode===b.mode? (a.time - b.time) || (a.mistakes - b.mistakes) : a.time - b.time));
  // keep top 10
  leaderboard = leaderboard.slice(0,10);
  localStorage.setItem('mst_leaderboard', JSON.stringify(leaderboard));
  renderLeaderboard();
}

function renderLeaderboard(){
  leaderboardEl.innerHTML = '';
  if(leaderboard.length===0){ leaderboardEl.textContent = 'No scores yet'; return; }
  for(const item of leaderboard){
    const d = document.createElement('div'); d.className='lb-item';
    d.textContent = `${item.mode.toUpperCase()} ‚Äî ${item.time}s ‚Äî mistakes:${item.mistakes} ‚Äî cost:${item.cost.toFixed(1)}`;
    leaderboardEl.appendChild(d);
  }
}

/* ----- Reset game progress (keep same graph) ----- */
function resetProgress(){
  // unaccept edges, clear misses and picked
  for(const e of edges){ e.accepted=false; e.flash = null; }
  mstEdges = [];
  mistakes = 0;
  primVisited = new Set();
  primStart = null;
  accuracyEl.textContent = '-';
  // If prim mode, set visited start again to nothing until user picks?
  if(algorithmMode === 'prim'){
    // choose start randomly when first click is expected
    primStart = Math.floor(Math.random()*nodes.length);
    primVisited.add(primStart);
  }
  resetTimer();
  optimalInfo.textContent = '-';
  render(); updateUI();
}

/* ----- Wire UI controls ----- */
newBtn.addEventListener('click', () => {
  NODE_COUNT = Math.max(4, Math.min(12, parseInt(nodeCountInput.value)||8));
  algorithmMode = modeSelect.value;
  generateGraph(NODE_COUNT);
  // If prim, set prim start now
  if(algorithmMode === 'prim'){
    primStart = Math.floor(Math.random()*nodes.length);
    primVisited.add(primStart);
    optimalInfo.textContent = `Prim start: ${primStart}`;
  } else {
    optimalInfo.textContent = '-';
  }
});
resetBtn.addEventListener('click', () => { resetProgress(); });
solveBtn.addEventListener('click', () => { showOptimal(); });
exportBtn.addEventListener('click', () => { exportGraph(); });
modeSelect.addEventListener('change', () => { algorithmMode = modeSelect.value; resetProgress(); optimalInfo.textContent='-'; });

/* ----- initial startup ----- */
function startInitial(){
  NODE_COUNT = Math.max(4, Math.min(12, parseInt(nodeCountInput.value)||8));
  algorithmMode = modeSelect.value;
  generateGraph(NODE_COUNT);
  // prim start default
  accuracyEl.textContent = '-';
  if(algorithmMode === 'prim'){
    primStart = Math.floor(Math.random()*nodes.length);
    primVisited.add(primStart);
    optimalInfo.textContent = `Prim start: ${primStart}`;
  }
  renderLeaderboard();
}
startInitial();

/* Poll to clear expired flashes and update candidate glow */
setInterval(()=>{
  let changed=false;
  for(const e of edges){
    if(e.flash && e.flash.expiry && Date.now() > e.flash.expiry){ e.flash=null; changed=true; }
  }
  if(changed) render();
}, 200);

</script>
</body>
</html>
